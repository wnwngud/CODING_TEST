import java.util.Scanner;

public class Main {

    public static int add(int[] dp, int n){
        if(dp[n] != 0 ) return dp[n]; //만약 n이 그 전에 구해놓은 값이 있더라면 그대로 사용

        else{
            dp[n] = add(dp, n-1) + add(dp, n-2) - add(dp, n-3);
            if(n%3 == 0 ) dp[n] +=1;
            
            /*n에 대해서 1+n-1, 2+n-2, 3+n-3의 경우로 나누어서 생각.
            만약 n이 5라고 가정한다면 5는 1+4, 2+3, 3+2로 나누어서 생각할 수 있다.
            
            이떄 1+4에서 1+(4를 1,2,3 으로 만들 수 있는 경우의 수)가 된다.
            4를 만들 수 있는 경우의 수에서 +1만 더해주면 되기 때문.
            
            이제 2+3에서 보면 마찬가지로 3을 만들 수 있는 경우의 수를 더해주면 되는데,
            주의해야할 점은 3을 만들 때 1이 들어간다면 앞서 4를 만들 수 있는 경우의 수와 중복이 되는
            경우가 있다는 것이다.
            4또한 1+3로 보았을 때로 생각해보면 4에는 이미 3을 만들 수 있는 모든 경우의 수에 +1이 더해진
            형태가 되기 때문이다.
            따라서 2+3의 경우에는 3을 만드는 경우에서 1이 들어간 경우를 빼주면 되는데
            이 또한 마찬가지로 1+2로 생각하면 된다. 
            즉, (3을 만드는 경우의 수) - (2를 만드는 경우의 수) 가 되면 결국 1을 제외하고
            3을 만드는 경우의 수가 들어있을 것이다.
            결국 dp[n-3]을 빼주면 되는 것이다.
            
            이제 5를 3+2로 보는 경우만 생각해주면 되는데, 이때는 앞에서 1과 2를 사용한 모든 경우의 수를
            구했기 때문에 5를 3으로만 구성해줄 수 있는 경우만 더해야한다.
            따라서 n%3==0이라면 +1, 아니라면 넘어가도록 해주면 된다.
            
            따라서 최종 점화식은
            dp[n] = d[n-1] + dp[n-2] - dp[n-3] + (n%3 == 0) ? 1 : 0
            이 된다.
            */

            return dp[n];
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int T = scanner.nextInt();


        int[] dp = new int[10001];

        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;

        for(int i=0; i<T; i++){
            int n = scanner.nextInt();
            System.out.println(add(dp, n));
        }
    }
}
